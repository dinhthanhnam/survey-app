import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Danh s√°ch c√°c c√¢u h·ªèi c·∫ßn lo·∫°i tr·ª´ (d·ª±a tr√™n question_name)
const excludedQuestions = [
    'C√¢u 1.13',
    'C√¢u 1.14',
    'C√¢u 6.2',
    'C√¢u 6.6',
    'C√¢u 6.7',
    'C√¢u 7.8',
    'C√¢u 8.4',
    'C√¢u 2.10',
    'C√¢u 3.2',
    'C√¢u 4.14',
];

// Danh s√°ch c√°c options c·∫ßn lo·∫°i tr·ª´ (d·ª±a tr√™n question_name v√† option_value)
const excludedOptions = [
    { question_name: 'C√¢u 1.14', option_value: 2 },
    { question_name: 'C√¢u 2', option_value: 1 },
];

async function updateWeightedValuesForQuestion(questionId, questionName) {
    try {
        // üîç L·∫•y t·∫•t c·∫£ c√°c options c·ªßa c√¢u h·ªèi, s·∫Øp x·∫øp theo option_value tƒÉng d·∫ßn
        const options = await prisma.question_options.findMany({
            where: {
                question_id: questionId,
                // Lo·∫°i tr·ª´ c√°c option theo question_name v√† option_value
                NOT: excludedOptions.map((opt) => ({
                    questions: { question_name: opt.question_name },
                    option_value: opt.option_value,
                })),
            },
            orderBy: { option_value: 'asc' },
        });

        let weight = 0; // B·∫Øt ƒë·∫ßu t·ª´ 0

        for (const option of options) {
            await prisma.question_options.update({
                where: { id: option.id },
                data: { weighted_value: weight },
            });
            weight++; // TƒÉng d·∫ßn gi√° tr·ªã weight
        }

        console.log(
            `‚úÖ C·∫≠p nh·∫≠t th√†nh c√¥ng weighted_value cho c√¢u h·ªèi ${questionName} (${questionId})`
        );
    } catch (error) {
        console.error('‚ùå L·ªói khi c·∫≠p nh·∫≠t weighted_value:', error);
    }
}

async function updateAllQuestionsWeightedValues() {
    // üîç L·∫•y t·∫•t c·∫£ c√¢u h·ªèi, lo·∫°i tr·ª´ nh·ªØng c√¢u trong excludedQuestions
    const questions = await prisma.questions.findMany({
        where: {
            NOT: { question_name: { in: excludedQuestions } },
        },
        select: { id: true, question_name: true },
    });

    for (const question of questions) {
        await updateWeightedValuesForQuestion(
            question.id,
            question.question_name
        );
    }
}

// üèÉ‚Äç‚ôÇÔ∏è Ch·∫°y c·∫≠p nh·∫≠t
await updateAllQuestionsWeightedValues();
